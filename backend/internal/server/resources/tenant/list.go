// Code generated by greenstar scripts; DO NOT EDIT.

package tenant

import (
	"errors"
	"fmt"
	"github.com/arikkfir/greenstar/backend/internal/server/middleware"
	"github.com/arikkfir/greenstar/backend/internal/server/util"
	"github.com/arikkfir/greenstar/backend/internal/util/lang"
	"github.com/shopspring/decimal"
	"net/http"
	"slices"
	"strconv"
	"strings"
	"time"
)

var (
	_ = decimal.Decimal{}
	_ = time.Time{}
)

var (
	sortableColumns = []string{"displayName"}
)

type ListRequest struct {
	properties  []string
	Offset      *uint    `url:"_offset,omitempty"`
	Count       *uint    `url:"_count,omitempty"`
	Sort        []string `url:"_sort,omitempty"`
	DisplayName *string  `url:"displayName,omitempty"`
	ID          *string  `url:"id,omitempty"`
}

func (lr *ListRequest) HasDisplayName() bool { return slices.Contains(lr.properties, "displayName") }
func (lr *ListRequest) HasID() bool          { return slices.Contains(lr.properties, "id") }
func (lr *ListRequest) UnmarshalFromRequest(r *http.Request) error {
	lr.properties = nil

	values := r.Form
	if values.Has("displayName") {
		lr.properties = append(lr.properties, "displayName")
		if rawValue := values.Get("displayName"); rawValue == util.QueryNilValue {
			lr.DisplayName = nil
		} else {
			sv := lang.PtrOf(rawValue)
			lr.DisplayName = sv
		}
	}
	if values.Has("id") {
		lr.properties = append(lr.properties, "id")
		if rawValue := values.Get("id"); rawValue == util.QueryNilValue {
			lr.ID = nil
		} else {
			sv := lang.PtrOf(rawValue)
			lr.ID = sv
		}
	}

	lr.Offset = nil
	if values.Has("_offset") {
		if v, err := strconv.ParseUint(values.Get("_offset"), 0, 0); err != nil {
			return fmt.Errorf("%w: invalid offset '%s'", util.ErrBadRequest, values.Get("_offset"))
		} else {
			lr.Offset = lang.PtrOf(uint(v))
		}
	}

	lr.Count = nil
	if values.Has("_count") {
		if v, err := strconv.ParseUint(values.Get("_count"), 0, 0); err != nil {
			return fmt.Errorf("%w: invalid count '%s'", util.ErrBadRequest, values.Get("_count"))
		} else {
			lr.Count = lang.PtrOf(uint(v))
		}
	}

	lr.Sort = nil
	if values.Has("_sort") {
		if sort := values.Get("_sort"); sort != "" {
			lr.Sort = strings.Split(sort, ",")
			for _, s := range lr.Sort {
				sortTokens := strings.Split(s, ":")
				var col, dir string
				if len(sortTokens) == 1 {
					col = sortTokens[0]
					dir = "asc"
				} else if len(sortTokens) == 2 {
					col = sortTokens[0]
					dir = strings.ToLower(sortTokens[1])
				} else {
					return fmt.Errorf("%w: invalid sort spec '%s'", util.ErrBadRequest, s)
				}
				if dir != "asc" && dir != "desc" {
					return fmt.Errorf("%w: invalid sort direction in '%s'", util.ErrBadRequest, s)
				} else if !slices.Contains(sortableColumns, col) {
					return fmt.Errorf("%w: column '%s' is not sortable", util.ErrBadRequest, col)
				}
			}
		}
	}

	return nil
}

type ListResponse struct {
	TotalCount uint     `json:"totalCount"`
	Items      []Tenant `json:"items"`
}

func (s *Server) List(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	l := util.Logger(ctx)

	tenantID := middleware.GetTenantID(ctx)
	if tenantID != "" {
		l = l.With("tenantID", tenantID)
	}
	authToken := middleware.GetToken(ctx)
	if !authToken.IsPermittedGlobally("tenants:list") {
		if tenantID != "" {
			if !authToken.IsPermittedForTenant(tenantID, "tenants:list") {
				util.ServeError(w, r, util.ErrForbidden)
				l.WarnContext(ctx, "Access denied", "permission", "tenants:list")
				return
			}
		} else {
			util.ServeError(w, r, util.ErrForbidden)
			l.WarnContext(ctx, "Access denied", "permission", "tenants:list")
			return
		}
	}

	if err := r.ParseForm(); err != nil {
		util.ServeError(w, r, errors.Join(util.ErrBadRequest, err))
		return
	}

	req := ListRequest{}
	if err := req.UnmarshalFromRequest(r); err != nil {
		util.ServeError(w, r, err)
		return
	}

	res, err := s.h.List(ctx, req)
	if err != nil {
		if code := util.ServeError(w, r, err); code >= http.StatusInternalServerError {
			l.ErrorContext(ctx, "Failed listing tenants", "err", err)
		}
		return
	}

	type ResponseWithOffset struct {
		Offset *uint `json:"offset,omitempty"`
		ListResponse
	}

	resWithOffset := ResponseWithOffset{
		Offset:       req.Offset,
		ListResponse: *res,
	}
	if err := util.Marshal(w, r, http.StatusOK, resWithOffset); err != nil {
		l.ErrorContext(ctx, "Failed marshaling tenants", "err", err)
		util.ServeError(w, r, err)
	}
}
